 Root Cause Analysis

  What's Actually Broken:
  - Abstractions don't enforce themselves (you have to remember vs compiler tells you)
  - Claude workflow lacks architectural review step (shortcuts get merged)
  - Implicit any everywhere (services returning untyped API responses)
  - No feedback loop (you discover problems 2 hours into debugging, not at compile time)

  Result: Development is painful ‚Üí You lose motivation ‚Üí Project stagnates

  ---
  Strategic Plan: Get Out of Refactor Hell

  PHASE 0: Fix the Workflow (Meta - Prevent Recurrence) üéØ START HERE

  Goal: Stop accumulating new debt while fixing old debt

  0.1: Make Violations Compilation Errors, Not Runtime Surprises

  // Currently: Forgot to extend BaseBehavior? Silent failure at runtime
  // Goal: Forgot to extend BaseBehavior? TypeScript compilation error

  // Enable strict mode in tsconfig.json
  {
    "compilerOptions": {
      "strict": true,
      "noImplicitAny": true,
      "strictNullChecks": true,
      "strictFunctionTypes": true,
      "noUncheckedIndexedAccess": true
    }
  }

  Why: Makes the compiler your safety net. You'll discover problems at compile time, not 2 hours into debugging.

  0.2: Add ESLint Architectural Rules

  // .eslintrc.json additions
  {
    "rules": {
      // Prevent BasePanel being imported in webview
      "no-restricted-imports": ["error", {
        "paths": [{
          "name": "../panels/base/BasePanel",
          "message": "BasePanel cannot be used in webview context"
        }]
      }],

      // Force explicit return types on public methods
      "@typescript-eslint/explicit-module-boundary-types": "error",

      // Ban `any` except with explicit eslint-disable + comment
      "@typescript-eslint/no-explicit-any": "error"
    }
  }

  Why: Catches architectural violations automatically. Wrong thing becomes hard, right thing becomes easy.

  0.3: Simplify CLAUDE.md (It's Confusing the Model)

  Current problem: CLAUDE.md is ~500 lines. Too much context for model to absorb consistently.

  Solution: Split into two files:

  CLAUDE.md (50 lines max)
  ‚îú‚îÄ MUST DO / MUST NOT DO (hard rules)
  ‚îú‚îÄ Link to detailed guides

  docs/PATTERNS/ (reference material)
  ‚îú‚îÄ SOLID_PATTERNS.md (when you need deep dive)
  ‚îú‚îÄ COMPONENT_LIFECYCLE.md
  ‚îú‚îÄ etc.

  New CLAUDE.md structure:
  # RULES (Non-Negotiable)

  ## üö´ NEVER
  - `any` without explicit comment
  - eslint-disable without user approval
  - BasePanel in webview code
  - Duplicate code 3+ times (Three Strikes Rule)

  ## ‚úÖ ALWAYS
  - Extend BaseBehavior for webview behaviors
  - Return typed models from services (never raw API responses)
  - Component creation through ComponentFactory
  - Use event bridges for updates (never updateWebview)

  ## üìö Details
  See docs/PATTERNS/ for examples. When unsure, ASK.

  Why: Short rules fit in context window reliably. Model can follow them consistently.

  0.4: Create Scaffolding (Eliminate "42 Things to Remember")

  Problem: Creating new panel = remember 42 steps = forget step 23 = 2hr debug session

  Solution: Code generator for common tasks

  # New command
  npm run new:panel PluginRegistration

  # Generates:
  # - src/panels/PluginRegistrationPanel.ts (from template)
  # - resources/webview/js/panels/PluginRegistrationBehavior.js (from template)
  # - Registers in activation
  # - Updates factory
  # - Creates test scaffold

  Template includes:
  - Correct BasePanel extension
  - Component initialization pattern
  - Event bridge setup
  - Message handling structure
  - BaseBehavior extension in webview

  Why: Right pattern is automatic. Can't forget steps.

  0.5: Architectural Review Workflow

  Current: Claude ‚Üí Code ‚Üí Merge ‚Üí Discover problems later

  Proposed: Claude ‚Üí Code ‚Üí Self-Review Checklist ‚Üí Merge

  // Add to end of every significant change:
  //
  // ARCHITECTURAL CHECKLIST (Claude must verify):
  // [ ] No `any` without explicit comment
  // [ ] All behaviors extend BaseBehavior
  // [ ] Services return typed models
  // [ ] No code duplication (DRY)
  // [ ] Changes compile with strict mode
  // [ ] No eslint-disable added
  //
  // If ANY checkbox is unchecked, explain why or fix it.

  Alternative: Use separate agent for review (but checklist is lighter weight)

  Why: Catches problems before merge, not after.

  ---
  PHASE 1: Foundation (Fix What's Killing Development) üèóÔ∏è

  Goal: Make development pleasant again. You should be able to create a new panel in 30 minutes, not 3 hours.

  1.1: BasePanel Abstraction (HIGH IMPACT)

  Problem: Component event handling duplicated across 8 panels (~500 lines)

  Solution: Extract to BasePanel

  // BasePanel.ts (new methods)
  export abstract class BasePanel {

    // TEMPLATE METHOD - handles ALL standard message patterns
    protected async handleMessage(message: WebviewMessage): Promise<void> {
      // Validate message (was duplicated 6+ times)
      if (!this.isValidMessage(message)) return;

      switch (message.command) {
        case 'component-event':
          await this.handleComponentEvent(message);
          return;
        case 'environment-changed':
        case 'environment-selected':
          await this.handleEnvironmentChange(message);
          return;
        // ... other common patterns
      }

      // Delegate to child for panel-specific messages
      await this.handlePanelMessage(message);
    }

    // Handles component events (was duplicated in 5 panels)
    private async handleComponentEvent(message: WebviewMessage): Promise<void> {
      const { componentId, eventType, data } = message.data || {};

      if (eventType === 'actionClicked') {
        const { actionId } = data;

        // Try standard actions (refresh, export, etc.)
        const handled = await this.handleStandardActions(actionId);
        if (handled) return;

        // Delegate to child for panel-specific actions
        await this.handlePanelAction(componentId, actionId, data);
      }

      // Delegate other component events
      await this.handleOtherComponentEvent(componentId, eventType, data);
    }

    // HOOK - Child panels override for custom actions
    protected async handlePanelAction(
      componentId: string,
      actionId: string,
      data: any
    ): Promise<void> {
      // Default: no custom actions
    }

    // HOOK - Child panels override for custom messages
    protected abstract handlePanelMessage(message: WebviewMessage): Promise<void>;
  }

  New panel becomes:
  export class PluginRegistrationPanel extends BasePanel {

    // Only override this for panel-specific actions
    protected async handlePanelAction(
      componentId: string,
      actionId: string,
      data: any
    ): Promise<void> {
      if (componentId === 'pluginReg-actionBar') {
        switch (actionId) {
          case 'register-plugin':
            await this.registerPlugin();
            break;
        }
      }
    }

    // Only override this for panel-specific messages
    protected async handlePanelMessage(message: WebviewMessage): Promise<void> {
      switch (message.command) {
        case 'plugin-selected':
          await this.loadPluginDetails(message.pluginId);
          break;
      }
    }
  }

  Impact:
  - 8 panels √ó 100 lines = 800 lines deleted
  - New panel = 20 lines instead of 120 lines
  - Pattern is enforced (abstract method = must implement)

  1.2: Service ‚Üí Model Type Safety (CRITICAL)

  Problem: Services returning implicit any (raw API responses)

  Solution: Define models, map in services

  // models/PluginAssembly.ts (NEW)
  export interface PluginAssembly {
    id: string;
    name: string;
    version: string;
    culture: string;
    publickeytoken: string;
    plugintypes: PluginType[];
  }

  export interface PluginType {
    id: string;
    typename: string;
    friendlyname: string;
    steps: PluginStep[];
  }

  // ... etc (explicit models for domain)

  // services/PluginRegistrationService.ts (BEFORE)
  async getPluginAssemblies(): Promise<any> {  // üö´ IMPLICIT ANY
    const response = await this.query.fetchData(/* ... */);
    return response.value;  // Raw API response
  }

  // services/PluginRegistrationService.ts (AFTER)
  async getPluginAssemblies(): Promise<PluginAssembly[]> {  // ‚úÖ TYPED
    const response = await this.query.fetchData(/* ... */);
    return response.value.map(raw => this.mapToPluginAssembly(raw));
  }

  private mapToPluginAssembly(raw: any): PluginAssembly {
    return {
      id: raw.pluginassemblyid,
      name: raw.name,
      version: raw.version,
      culture: raw.culture,
      publickeytoken: raw.publickeytoken,
      plugintypes: (raw.plugintypes || []).map(pt => this.mapToPluginType(pt))
    };
  }

  Why this matters:
  - Compiler catches typos: plugin.nmae ‚Üí error, not runtime undefined
  - Refactoring is safe: Rename PluginAssembly.name ‚Üí compiler finds all usages
  - No more "what properties does this have?" guessing games

  Action: Add models for ALL services (do this systematically)

  1.3: BaseBehavior Enforcement

  Problem: 4 panel behaviors don't extend BaseBehavior (silent failures)

  Solution:
  1. Make all 4 panel behaviors extend BaseBehavior
  2. Add TypeScript interface enforcement (if possible in JS via JSDoc)

  // pluginRegistrationBehavior.js (BEFORE)
  class PluginRegistrationBehavior {
    static handleMessage(message) { /* ... */ }
  }

  // pluginRegistrationBehavior.js (AFTER)
  class PluginRegistrationBehavior extends BaseBehavior {
    static getComponentType() { return 'PluginRegistrationPanel'; }

    static onComponentUpdate(instance, data) {  // ENFORCED by base class
      // Must implement - compiler/runtime catches if missing
    }
  }

  1.4: Delete Dangerous Duplicates (IMMEDIATE)

  Critical: Delete one of these NOW (before Phase 1 even starts)
  - PanelUtils.js OR panel-utils.js (pick one, delete other)
  - Reason: Unpredictable behavior based on load order - this is actively dangerous

  ---
  PHASE 2: Safety Net (Catch Regressions During Refactor) üõ°Ô∏è

  Goal: Know when you break something during refactor

  2.1: Smoke Tests (Lightweight, Not TDD)

  Not proposing: 100% test coverage, full TDD
  Proposing: "Does this basic thing work?" tests

  // tests/smoke/panels.test.ts
  describe('Panel Smoke Tests', () => {

    test('PluginRegistrationPanel instantiates without error', () => {
      const panel = new PluginRegistrationPanel(mockWebviewPanel, mockUri);
      expect(panel).toBeDefined();
    });

    test('PluginRegistrationPanel renders HTML', () => {
      const panel = new PluginRegistrationPanel(mockWebviewPanel, mockUri);
      const html = panel.getHtmlContent();
      expect(html).toContain('pluginRegistration-actionBar');
    });

    test('Component event message handling does not throw', async () => {
      const panel = new PluginRegistrationPanel(mockWebviewPanel, mockUri);
      const message = {
        command: 'component-event',
        data: {
          componentId: 'pluginReg-actionBar',
          eventType: 'actionClicked',
          data: { actionId: 'refresh' }
        }
      };
      await expect(panel.handleMessage(message)).resolves.not.toThrow();
    });
  });

  Why: Catches "I refactored BasePanel and broke 3 panels" immediately, not 2 hours later

  Effort: ~30min per panel to write, massive savings in debugging time

  2.2: Pre-commit Checks

  // package.json
  {
    "scripts": {
      "precommit": "npm run lint && npm run type-check && npm run test:smoke",
      "type-check": "tsc --noEmit",
      "test:smoke": "jest --testPathPattern=smoke"
    }
  }

  Why: Can't commit broken code. Catches problems immediately.

  ---
  PHASE 3: Systematic DRY Elimination üî®

  Goal: Eliminate "fix it in 8 places" scenarios

  This is the tedious but straightforward cleanup work. Once foundation is solid (Phase 1) and safety net exists (Phase 2),
  systematically eliminate duplication:

  1. Deployment Settings Sync (2 panels, exact duplication - extract to BasePanel helper)
  2. Solution Loading Pattern (2 panels - extract helper)
  3. Message validation boilerplate (already in Phase 1 BasePanel)
  4. "Open in Maker" URL building (4+ panels - use UrlBuilderService consistently)
  5. Decompose ComponentUtils God Object (780 lines ‚Üí multiple focused classes)
  6. Decompose PanelUtils SRP violations

  ---
  PHASE 4: Polish üßπ

  Goal: Clean navigation, clear structure

  This is what you do LAST (after code works well):
  1. Flatten component categories (if still needed)
  2. Rename panel behaviors to PascalCase
  3. Delete orphaned webview files
  4. Delete deprecated code (~145 lines)
  5. Update documentation

  ---
  Execution Strategy

  Option A: "Take the Weekend" ‚úÖ RECOMMENDED

  - Friday night: Phase 0 (workflow setup)
  - Saturday: Phase 1 (foundation) + Phase 2 (smoke tests)
  - Sunday: Phase 3 (DRY elimination)
  - Monday: Back to feature development, much smoother

  Pros: Rip the bandaid off, foundation solid before continuing
  Cons: 2-3 days of no feature work

  Option B: "Incremental"

  - Week 1: Phase 0
  - Week 2: Phase 1 item 1.1 (BasePanel)
  - Week 3: Phase 1 item 1.2 (Service models)
  - etc.

  Pros: Ship features between phases
  Cons: Foundation stays broken longer, more overall time

  My recommendation: Option A. The pain is acute, not chronic. Get foundation right, then enjoy smooth development.

  ---
  Addressing Your Meta-Questions

  "Do I need multiple agents?"

  Short answer: Not yet, but consider explicit review step

  Current workflow:
  User asks ‚Üí Claude codes ‚Üí Merge ‚Üí Discover problems later

  Better workflow:
  User asks ‚Üí Claude codes ‚Üí **Claude self-reviews with checklist** ‚Üí Merge

  The checklist in Phase 0.5 might be enough. If problems persist, THEN consider separate review agent.

  "Is CLAUDE.md part of the problem?"

  Yes, but it's fixable. It's too long to fit in context reliably. Phase 0.3 addresses this - extract hard rules into short
  reference card.

  "How do I prevent this from happening again?"

  Phase 0 is specifically designed to answer this:
  - Strict TypeScript = compiler catches problems
  - ESLint rules = catches architectural violations
  - Scaffolding = can't forget steps
  - Review checklist = catches problems before merge

  The key insight: Make the right thing easy and the wrong thing hard.

  Currently, it's easier to add any than to define a model. It's easier to duplicate code than to extract it. Fix the incentives.

  ---
  Success Criteria

  Before (current state):
  - Create new panel: 3-4 hours + 2hr debug session
  - Add new component: Remember 42 things, forget 1, break silently
  - Fix bug: Must fix in 8 places, miss 2, create inconsistency
  - Feel: Demotivated, dread opening project

  After (target state):
  - Create new panel: 30 minutes using scaffold
  - Add new component: TypeScript guides you, can't forget steps
  - Fix bug: Fix in BasePanel, all panels fixed automatically
  - Feel: Confident, enjoy building features

  ---
  The Plan (TL;DR)

‚óèUser approved Claude's plan:
  ‚éø Strategic Refactor Plan: Get Out of Refactor Hell

    PHASE 0: Fix the Workflow (Meta) üéØ START HERE

    1. Enable TypeScript strict mode (make violations compile errors)
    2. Add ESLint architectural rules (catch pattern violations)
    3. Simplify CLAUDE.md to 50-line "Rules Card" (too long = model confusion)
    4. Create scaffolding/templates for panels/components (eliminate "42 things to remember")
    5. Add architectural review checklist (catch problems before merge)

    Goal: Stop accumulating new debt. Make right thing easy, wrong thing hard.

    PHASE 1: Foundation üèóÔ∏è

    1. BasePanel Abstraction - Extract component-event handling to base class (~800 lines eliminated, new panel = 20 lines vs
    120)
    2. Service ‚Üí Model Type Safety - Ban implicit any, define typed models for all API responses, map in services
    3. BaseBehavior Enforcement - Make all 4 panel behaviors extend BaseBehavior (prevents silent failures)
    4. Delete Duplicate PanelUtils - One of PanelUtils.js/panel-utils.js must go (dangerous load-order dependency)

    Goal: Solid foundation. Development becomes pleasant instead of painful.

    PHASE 2: Safety Net üõ°Ô∏è

    1. Smoke Tests (lightweight) - "Does panel instantiate? Does it render? Does message handling not throw?"
    2. Pre-commit Checks - lint + type-check + smoke tests before commit

    Goal: Catch regressions immediately, not 2 hours into debugging.

    PHASE 3: DRY Elimination üî®

    1. Extract deployment settings sync (2 panels, exact duplication)
    2. Extract solution loading pattern (2 panels)
    3. Standardize "Open in Maker" (4+ panels)
    4. Decompose ComponentUtils God Object (780 lines ‚Üí focused classes)
    5. Decompose PanelUtils SRP violations

    Goal: Eliminate "fix it in 8 places" scenarios.

    PHASE 4: Polish üßπ

    1. Flatten component categories
    2. Rename panel behaviors to PascalCase
    3. Delete orphaned files & deprecated code
    4. Update documentation

    Goal: Clean navigation, clear structure.

    ---
    Execution: "Take the Weekend" ‚úÖ RECOMMENDED

    - Friday night: Phase 0 (2-3 hours)
    - Saturday: Phase 1 + Phase 2 (6-8 hours)
    - Sunday: Phase 3 (4-6 hours)
    - Monday: Back to features, smooth development

    Success Metric: New panel = 30min instead of 3-4hrs + 2hr debug session.