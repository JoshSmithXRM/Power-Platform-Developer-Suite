# Communication Patterns

> **Purpose:** Explain how Extension Host and Webview communicate.

## Table of Contents
- [Overview](#overview)
- [The Two Contexts](#the-two-contexts)
- [Message Passing](#message-passing)
- [Recommended Patterns](#recommended-patterns)
- [Anti-Patterns](#anti-patterns)
- [Implementation Guide](#implementation-guide)

---

## Overview

### For C# Developers

If you've built Blazor apps, you're used to this:

```csharp
// Blazor - Direct C# method calls from UI
<button @onclick="LoadData">Load</button>

@code {
    private async Task LoadData()
    {
        // C# runs in browser via WebAssembly
        var data = await Http.GetFromJsonAsync<Data[]>("api/data");
        this.items = data;
    }
}
```

**VS Code webviews don't work like this.** There's no shared runtime.

Instead, it's more like **ASP.NET MVC with SignalR**:
- Extension Host = ASP.NET backend (runs in Node.js)
- Webview = Browser frontend (HTML/JS/CSS in iframe)
- Communication = SignalR messages (but simpler)

```
┌─────────────────────────────────┐     postMessage     ┌─────────────────────────────────┐
│      Extension Host             │◄──────────────────►│          Webview                │
│      (Node.js / TypeScript)     │                     │     (Browser / JavaScript)      │
│                                 │                     │                                 │
│  - Business logic               │                     │  - HTML rendering               │
│  - API calls                    │                     │  - User interaction             │
│  - File system                  │                     │  - DOM manipulation             │
│  - VS Code API                  │                     │  - CSS styling                  │
│  - Panels                       │                     │  - Behaviors                    │
│  - Services                     │                     │  - No VS Code API               │
│  - Repositories                 │                     │  - No Node.js                   │
└─────────────────────────────────┘                     └─────────────────────────────────┘
     ↑                                                       ↑
     └─ Full Node.js environment                             └─ Sandboxed browser context
```

---

## The Two Contexts

### Extension Host Context

**What it is:** Your main TypeScript code running in Node.js.

**What it can do:**
- ✅ Call VS Code API (`vscode.window`, `vscode.workspace`, etc.)
- ✅ Make HTTP requests (to Dataverse, Power Platform)
- ✅ Read/write files
- ✅ Access Node.js modules
- ✅ Use TypeScript features
- ✅ Run business logic

**What it cannot do:**
- ❌ Directly manipulate HTML/DOM
- ❌ Run browser JavaScript
- ❌ Access webview's `window` or `document`

**File locations:**
- `src/**/*.ts` (all TypeScript files)
- Panels, components, services, repositories

---

### Webview Context

**What it is:** An isolated iframe running HTML/JavaScript/CSS.

**What it can do:**
- ✅ Render HTML
- ✅ Manipulate DOM
- ✅ Handle user interactions (clicks, input)
- ✅ Run JavaScript (ES6+)
- ✅ Apply CSS styling

**What it cannot do:**
- ❌ Call VS Code API
- ❌ Import Node.js modules
- ❌ Make direct HTTP requests (blocked by CSP)
- ❌ Access file system
- ❌ Access TypeScript code directly

**File locations:**
- `resources/webview/**/*.js` (JavaScript behaviors)
- `resources/webview/**/*.css` (styles)
- HTML is generated by components

---

## Message Passing

Communication between contexts happens via `postMessage` API.

### Webview → Extension Host

**When:** User interacts with UI (clicks button, selects dropdown, etc.)

```javascript
// Webview (JavaScript)
// User clicks a button
document.querySelector('#load-button').addEventListener('click', () => {
    // Send message to extension host
    vscode.postMessage({
        command: 'load-data',
        environmentId: '12345',
        filters: { status: 'active' }
    });
});
```

```typescript
// Extension Host (TypeScript)
// Panel receives message
this.panel.webview.onDidReceiveMessage(async (message) => {
    if (message.command === 'load-data') {
        await this.handleLoadData(
            message.environmentId,
            message.filters
        );
    }
});
```

**C# Analogy:**
```csharp
// Like an MVC controller receiving a POST request
[HttpPost]
public async Task<IActionResult> LoadData(string environmentId, FilterDto filters)
{
    var data = await _service.LoadData(environmentId, filters);
    return Json(data);
}
```

---

### Extension Host → Webview

**When:** Data changes, need to update UI

```typescript
// Extension Host (TypeScript)
// Send data to webview
this.panel.webview.postMessage({
    command: 'update-table',
    componentId: 'importJobs-table',
    data: viewModels
});
```

```javascript
// Webview (JavaScript)
// Listen for messages from extension host
window.addEventListener('message', (event) => {
    const message = event.data;

    if (message.command === 'update-table') {
        updateTable(message.componentId, message.data);
    }
});
```

**C# Analogy:**
```csharp
// Like SignalR pushing data to client
await Clients.All.SendAsync("UpdateTable", componentId, data);
```

---

## Recommended Patterns

### Pattern 1: Command Pattern (User Actions)

Use for handling user-initiated actions.

**Webview sends commands:**
```javascript
// Button click
vscode.postMessage({ command: 'refresh' });

// Dropdown change
vscode.postMessage({ command: 'environment-changed', environmentId: '123' });

// Context menu
vscode.postMessage({ command: 'context-menu', action: 'viewXml', rowId: 'abc' });
```

**Extension Host handles commands:**
```typescript
protected async handleMessage(message: WebviewMessage): Promise<void> {
    switch (message.command) {
        case 'refresh':
            await this.handleRefresh();
            break;

        case 'environment-changed':
            await this.handleEnvironmentChanged(message.environmentId);
            break;

        case 'context-menu':
            await this.handleContextMenu(message.action, message.rowId);
            break;
    }
}
```

---

### Pattern 2: Update Pattern (Data Changes)

Use for pushing data updates to webview.

**Extension Host sends updates:**
```typescript
// Update component data
this.postMessage({
    command: 'component-update',
    componentId: 'importJobs-table',
    data: {
        rows: viewModels,
        loading: false
    }
});

// Update component state
this.postMessage({
    command: 'component-state',
    componentId: 'importJobs-table',
    state: {
        loading: true,
        loadingMessage: 'Loading import jobs...'
    }
});
```

**Webview receives updates:**
```javascript
window.addEventListener('message', (event) => {
    const message = event.data;

    if (message.command === 'component-update') {
        const behavior = ComponentRegistry.get(message.componentId);
        behavior.onComponentUpdate(message.data);
    }
});
```

---

### Pattern 3: Request-Response (Query Pattern)

Use when webview needs data from extension host.

**Webview requests data:**
```javascript
// Create promise for response
const requestId = generateUniqueId();
const responsePromise = new Promise((resolve) => {
    const handler = (event) => {
        const message = event.data;
        if (message.command === 'query-response' && message.requestId === requestId) {
            window.removeEventListener('message', handler);
            resolve(message.data);
        }
    };
    window.addEventListener('message', handler);
});

// Send query
vscode.postMessage({
    command: 'query-environments',
    requestId: requestId
});

// Await response
const environments = await responsePromise;
```

**Extension Host responds:**
```typescript
protected async handleMessage(message: WebviewMessage): Promise<void> {
    if (message.command === 'query-environments') {
        const environments = await this.environmentService.getAll();

        this.postMessage({
            command: 'query-response',
            requestId: message.requestId,
            data: environments
        });
    }
}
```

**Note:** This pattern adds complexity. Prefer **pushing data proactively** instead of pulling on-demand.

---

## Anti-Patterns

### ❌ Anti-Pattern 1: Storing State in Webview

**Problem:** Webview is disposable - it can be hidden/destroyed at any time.

```javascript
// ❌ BAD - State in webview
let selectedEnvironmentId = null;

vscode.postMessage({ command: 'load-data', environmentId: selectedEnvironmentId });
```

**Solution:** Store state in extension host.

```typescript
// ✅ GOOD - State in extension host
export class Panel extends BasePanel {
    private selectedEnvironmentId?: string;

    protected async handleEnvironmentChanged(environmentId: string): Promise<void> {
        this.selectedEnvironmentId = environmentId; // Store here
        await this.loadData(environmentId);
    }

    protected async handleRefresh(): Promise<void> {
        if (this.selectedEnvironmentId) {
            await this.loadData(this.selectedEnvironmentId); // Use stored state
        }
    }
}
```

---

### ❌ Anti-Pattern 2: Business Logic in Webview

**Problem:** Webview should only handle UI, not business rules.

```javascript
// ❌ BAD - Business logic in webview
function calculateJobStatus(job) {
    if (job.completedon) {
        return job.progress < 100 ? 'Failed' : 'Completed';
    }
    return job.progress > 0 ? 'In Progress' : 'Pending';
}
```

**Solution:** Do logic in extension host, send display-ready data.

```typescript
// ✅ GOOD - Business logic in domain entity
export class ImportJob {
    getStatus(): JobStatus {
        if (this.isCompleted()) {
            return this.progress.isComplete()
                ? JobStatus.Completed
                : JobStatus.Failed;
        }
        return this.progress.hasStarted()
            ? JobStatus.InProgress
            : JobStatus.Pending;
    }
}

// Mapper creates ViewModel with display-ready status
const viewModel = {
    statusLabel: 'In Progress',
    statusVariant: 'in-progress'
};
```

---

### ❌ Anti-Pattern 3: Frequent Message Ping-Pong

**Problem:** Too many back-and-forth messages.

```javascript
// ❌ BAD - Multiple round trips
vscode.postMessage({ command: 'get-environment' });
// Wait for response...
vscode.postMessage({ command: 'get-solutions', environmentId });
// Wait for response...
vscode.postMessage({ command: 'load-components', solutionId });
```

**Solution:** Batch operations in extension host.

```typescript
// ✅ GOOD - Single request, extension host orchestrates
protected async handleEnvironmentChanged(environmentId: string): Promise<void> {
    // Extension host does all the work
    const environment = await this.environmentService.getById(environmentId);
    const solutions = await this.solutionService.getByEnvironment(environmentId);
    const defaultSolution = solutions[0];
    const components = defaultSolution
        ? await this.componentService.getBySolution(defaultSolution.id)
        : [];

    // Single update with all data
    this.postMessage({
        command: 'update-all',
        environment: environment,
        solutions: solutions,
        components: components
    });
}
```

---

### ❌ Anti-Pattern 4: Direct DOM Manipulation in Extension Host

**Problem:** Extension host can't access DOM.

```typescript
// ❌ BAD - Trying to manipulate DOM from extension host
const element = document.getElementById('table'); // ❌ undefined!
element.innerHTML = '<tr>...</tr>';
```

**Solution:** Generate HTML in components, send to webview.

```typescript
// ✅ GOOD - Component generates HTML
export class DataTableComponent {
    generateHTML(): string {
        return `<table id="${this.config.id}">...</table>`;
    }
}

// Webview behavior updates DOM
class DataTableBehavior {
    onComponentUpdate(data) {
        this.element.querySelector('tbody').innerHTML = this.renderRows(data.rows);
    }
}
```

---

## Implementation Guide

### 1. Component Update Flow (Recommended)

This is the pattern we use for updating component data.

#### Extension Host Side

```typescript
// Component class
export class DataTableComponent extends BaseComponent {
    setData(data: unknown[]): void {
        this.config.data = data;
        this.notifyUpdate(); // Triggers message to webview
    }

    private notifyUpdate(): void {
        // Send update message via event bridge
        this.emit('component-update', {
            componentId: this.config.id,
            data: this.config.data
        });
    }
}

// Panel uses component
this.dataTableComponent.setData(viewModels);
// ↑ This triggers the message automatically
```

#### Webview Side

```javascript
// Behavior class
class DataTableBehavior extends BaseBehavior {
    getComponentType() {
        return 'DataTable';
    }

    // Called when component data changes
    onComponentUpdate(data) {
        this.updateTableRows(data.data);
    }

    updateTableRows(rows) {
        const tbody = this.element.querySelector('tbody');
        tbody.innerHTML = rows.map(row => this.renderRow(row)).join('');
    }

    renderRow(row) {
        return `
            <tr data-row-id="${row.id}">
                <td>${row.solutionName}</td>
                <td>${row.statusLabel}</td>
            </tr>
        `;
    }
}

// Register behavior
ComponentUtils.registerBehavior(new DataTableBehavior());
```

---

### 2. User Action Flow (Recommended)

This is the pattern we use for handling user interactions.

#### Webview Side

```javascript
// Behavior captures user action
class DataTableBehavior extends BaseBehavior {
    setupEventHandlers() {
        // Handle row clicks
        this.element.addEventListener('click', (e) => {
            if (e.target.matches('[data-action="viewXml"]')) {
                const rowId = e.target.closest('tr').dataset.rowId;

                // Send command to extension host
                vscode.postMessage({
                    command: 'row-action',
                    action: 'viewXml',
                    rowId: rowId
                });
            }
        });
    }
}
```

#### Extension Host Side

```typescript
// Panel handles message
protected async handleMessage(message: WebviewMessage): Promise<void> {
    if (message.command === 'row-action') {
        await this.handleRowAction(message.action, message.rowId);
    }
}

private async handleRowAction(action: string, rowId: string): Promise<void> {
    if (action === 'viewXml') {
        // Delegate to command
        await this.viewJobXmlCommand.execute({ jobId: rowId });
    }
}
```

---

### 3. Loading States

Show loading indicators while data loads.

```typescript
// Extension Host - Set loading
this.dataTableComponent.setLoading(true, 'Loading import jobs...');

// Fetch data
const response = await this.loadImportJobsUseCase.execute({ environmentId });

// Update with data
this.dataTableComponent.setData(response.jobs);
this.dataTableComponent.setLoading(false);
```

```javascript
// Webview - Handle loading state
onComponentUpdate(data) {
    if (data.loading) {
        this.showLoadingIndicator(data.loadingMessage);
    } else {
        this.hideLoadingIndicator();
        this.updateTableRows(data.data);
    }
}
```

---

## Message Type Definitions

### Standard Message Types

```typescript
// Base message
interface WebviewMessage {
    command: string;
    [key: string]: unknown;
}

// User action
interface ActionMessage extends WebviewMessage {
    command: 'action-clicked' | 'row-action' | 'context-menu';
    componentId: string;
    actionId?: string;
    rowId?: string;
}

// Component update
interface ComponentUpdateMessage extends WebviewMessage {
    command: 'component-update';
    componentId: string;
    data: unknown;
}

// State change
interface StateChangeMessage extends WebviewMessage {
    command: 'state-change';
    componentId: string;
    state: {
        loading?: boolean;
        loadingMessage?: string;
        error?: string;
    };
}

// Environment change
interface EnvironmentChangedMessage extends WebviewMessage {
    command: 'environment-changed';
    environmentId: string;
}
```

---

## Debugging Communication

### Extension Host Logging

```typescript
protected async handleMessage(message: WebviewMessage): Promise<void> {
    this.logger.debug('Message received', { command: message.command, data: message });

    // Handle message...

    this.logger.debug('Message handled', { command: message.command });
}
```

### Webview Logging

```javascript
// Log outgoing messages
const originalPostMessage = vscode.postMessage;
vscode.postMessage = (message) => {
    console.log('[Webview → Extension]', message);
    originalPostMessage(message);
};

// Log incoming messages
window.addEventListener('message', (event) => {
    console.log('[Extension → Webview]', event.data);
});
```

---

## Key Takeaways

1. **Two separate contexts** - Extension Host (Node.js) and Webview (browser)
2. **No direct function calls** - Must use postMessage
3. **Extension Host owns state** - Webview is disposable
4. **Business logic stays in Extension Host** - Webview only handles UI
5. **Push data, don't pull** - Proactively send updates vs. waiting for requests
6. **Type-safe messages** - Define message interfaces
7. **Event-driven architecture** - User actions → commands, data changes → updates

---

## C# Developer Summary

| Blazor/ASP.NET | VS Code Extension |
|----------------|-------------------|
| Direct method calls | postMessage |
| Blazor component | Panel + Component + Behavior |
| @onclick handler | event listener → postMessage |
| StateHasChanged() | component.notifyUpdate() |
| SignalR Hub | Webview message handler |
| Dependency injection | ServiceFactory |
| IActionResult | WebviewMessage |
