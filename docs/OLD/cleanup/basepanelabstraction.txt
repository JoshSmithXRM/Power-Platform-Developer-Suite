 Missing base panel abstraction:
 Root Cause Analysis

  Bad Assumption:
  I created the StateDebugPanel message handling from scratch instead of referencing an existing implementation.I assumed the
  pattern was action - clicked without checking what the current architecture actually uses.

  What I should have done:
  // Step 1: Look at ANY recent panel
  grep "component-event" src / panels / PluginRegistrationPanel.ts

  // Step 2: Copy the exact pattern
  // Don't guess, don't assume, COPY what works

  But There's a Bigger Problem: Missing Abstraction

  Look at this code duplication across 8 panels:

PluginRegistrationPanel.ts:
  case 'component-event': {
    const { componentId, eventType, data } = message.data || {};
    if (componentId === 'pluginRegistration-actionBar' && eventType === 'actionClicked') {
        const { actionId } = data;
        const handled = await this.handleStandardActions(actionId);
        if (handled) return;
        // ... panel-specific actions
    }
}

EnvironmentVariablesPanel.ts:
  case 'component-event': {
    const { componentId, eventType, data } = message.data || {};
    if (componentId === 'envVars-actionBar' && eventType === 'actionClicked') {
        const { actionId } = data;
        // ... same pattern
    }
}

ConnectionReferencesPanel.ts, MetadataBrowserPanel.ts, ImportJobViewerPanel.ts, SolutionExplorerPanel.ts,
    PluginTraceViewerPanel.ts...
  All have identical code with just different componentId strings.

  Three Strikes Rule Violation

  This is the same code in 8 + places.We should have abstracted this long ago.

  The Missing Abstraction

  BasePanel should provide:

  // In BasePanel
  protected async handleMessage(message: WebviewMessage): Promise < void> {
    switch(message.command) {
          case 'component-event':
    await this.handleComponentEvent(message);
    return;
    // ... other common handlers
}

// Delegate to child
await this.handlePanelSpecificMessage(message);
  }

  protected async handleComponentEvent(message: WebviewMessage): Promise < void> {
    const { componentId, eventType, data } = message.data || {};

    // Standard ActionBar handling
    if(eventType === 'actionClicked') {
    const { actionId } = data;

    // Try standard actions first
    const handled = await this.handleStandardActions(actionId);
    if (handled) return;

    // Delegate to child for panel-specific actions
    await this.handlePanelAction(componentId, actionId);
}

// Other component events (split panel, tree, etc.)
await this.handleOtherComponentEvents(componentId, eventType, data);
  }

  // Child panels only override this for custom actions
  protected async handlePanelAction(componentId: string, actionId: string): Promise < void> {
    // Default: no custom actions
}

  Then StateDebugPanel becomes:
  protected async handlePanelAction(componentId: string, actionId: string): Promise < void> {
    if(componentId === 'stateDebug-actions') {
    switch (actionId) {
        case 'clear-all': await this.clearAllState(); break;
        case 'export': await this.exportState(); break;
    }
}
  }

  No more duplication.

    Summary

  How we got here:
1. ❌ Bad assumption - I guessed the pattern instead of referencing existing code
2. ❌ Didn't follow existing pattern - Should have copied from PluginRegistrationPanel
3. ❌ Ignored duplication smell - This code is duplicated in 8 + panels(Three Strikes violation)

  The proper fix:
1. Short - term: I fixed StateDebugPanel to match the current pattern ✓
2. Long - term: Refactor component - event handling into BasePanel to eliminate duplication across all panels

  Should we implement the BasePanel abstraction now to prevent this from happening again ?